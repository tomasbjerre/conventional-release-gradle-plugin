// ---- default config ----
enum REPOTYPE {
	JAR, GRADLE, COMMAND
}

interface ConventionalReleasePluginExtension {
	Property<REPOTYPE> getRepoType()
	// Format: org:org,com:com
	Property<String> getRelocate()
	Property<String> getIgnoreCommitsIfMessageMatches()
	// If not prepending, it will rewrite the entire changelog
	Property<String> getPrependChangelogToFile()
	Property<String> getUpdateChangelog()
	Property<String> getSetVersionConventional()
	Property<String> getWebsite()
	Property<String> getVcsUrl()
	Property<String> getLicenseName()
	Property<String> getLicenseUrl()
	Property<String> getDeveloperId() 
	Property<String> getDeveloperName() 
	Property<String> getDeveloperEmail() 
	Property<String> getMavenRepositoryName() 
	Property<String> getMavenRepositoryUrl() 
	Property<String> getNexusUsernameEnvOrProp() 
	Property<String> getNexusPasswordEnvOrProp() 
	Property<String> getSigningKeyEnvOrProp() 
	Property<String> getSigningPasswordEnvOrProp()
	Property<String> getTags() 
	Property<String> getImplementationClass()
	Property<String> getStripGradlePluginSuffix()
	// If it should be published to Plugin Portal or Central
	Property<String> getPublishGradlePluginToGradlePortal()
	// If using groovy-gradle-plugin it will add a plugin that needs to be adjusted
	Property<String> getAdjustExistingGradlePluginPlugins()
	// If not using groovy-gradle-plugin a plugin needs to be added
	Property<String> getAddGradlePluginPlugins()
}

def extension = project.extensions.create("conventionalRelease", ConventionalReleasePluginExtension)
extension.repoType.convention(REPOTYPE.JAR)
extension.relocate.convention("")
extension.ignoreCommitsIfMessageMatches.convention("^\\[maven-release-plugin\\].*|^\\[Gradle Release Plugin\\].*|^Merge.*|.*\\[GRADLE SCRIPT\\].*")
extension.prependChangelogToFile.convention(true)
extension.updateChangelog.convention(true)
extension.setVersionConventional.convention(true)
extension.website.convention("https://github.com/tomasbjerre/" + project.name)
extension.vcsUrl.convention("https://github.com/tomasbjerre/" + project.name)
extension.licenseName.convention("The Apache Software License, Version 2.0")
extension.licenseUrl.convention("http://www.apache.org/licenses/LICENSE-2.0.txt")
extension.developerId.convention("tomasbjerre")
extension.developerName.convention("Tomas Bjerre")
extension.developerEmail.convention("tomas.bjerre85@gmail.com")
extension.mavenRepositoryName.convention("nexus")
extension.mavenRepositoryUrl.convention("https://oss.sonatype.org/service/local/")
extension.nexusUsernameEnvOrProp.convention("nexusUsername")
extension.nexusPasswordEnvOrProp.convention("nexusPassword")
extension.signingKeyEnvOrProp.convention("signing.keyId")
extension.signingPasswordEnvOrProp.convention( "signing.password")
extension.implementationClass.convention("")
extension.stripGradlePluginSuffix.convention(true)
extension.publishGradlePluginToGradlePortal.convention(true)
extension.adjustExistingGradlePluginPlugins.convention(false)
extension.addGradlePluginPlugins.convention(true)
// ---- default config ----


if (extension.setVersionConventional) {
	logger.lifecycle("Setting version from conventional commits")
	project.ext.setVersionConventional = extension.setVersionConventional
	project.ext.suffixSnapshot=false
	project.ext.suffixSnapshotIfNotTagged=false
}
if (extension.useShadowJar) {
	project.plugins.apply "com.gradleup.shadow"
}
project.plugins.apply 'java-library'
project.plugins.apply 'maven-publish'
project.plugins.apply 'signing'
project.plugins.apply "io.github.gradle-nexus.publish-plugin"
if (extension.repoType.get() == "GRADLE"
		&& extension.publishGradlePluginToGradlePortal) {
	project.plugins.apply "com.gradle.plugin-publish"
}
if (extension.updateChangelog
		|| extension.setVersionConventional) {
	project.plugins.apply "se.bjurr.gitchangelog.git-changelog-gradle-plugin"
	gitChangelogSemanticVersion {
		suffixSnapshotIfNotTagged = false
	}
	gitChangelog {
		ignoreCommitsIfMessageMatches = extension.ignoreCommitsIfMessageMatches
		prependToFile = extension.prependChangelogToFile
	}
}


/**
 * NPM
 */
task publishNpm() {
	doLast {
		runCommand(['npm', 'publish'])
	}
}

task setupNpmJavaRunnerFiles() {
	doLast {
		shouldGitIgnore('index.js')
		copyIfFound("npm-java-runner-index.js", "index.js")
		shouldGitIgnore('package.json')
		shouldGitIgnore('package-lock.json')
		shouldGitIgnore('node_modules')
		copyIfFound("npm-java-runner-package.json", "package.json")
		ant.replace(file: new File("package.json"), token: "PKG_NAME", value: project.name)
		ant.replace(file: new File("package.json"), token: "PKG_VERSION", value: version)
		ant.replace(file: new File("package.json"), token: "PKG_WEBSITE", value: extension.website)
		ant.replace(file: new File("package.json"), token: "PKG_GIT", value: extension.vcsUrl)
		ant.replace(file: new File("package.json"), token: "PKG_AUTHOR", value: extension.developerName)
		ant.replace(file: new File("package.json"), token: "PKG_DESCRIPTION", value: project.description.replaceAll("[\"']",""))
	}
}

/**
 * Relocating
 */
if (extension.useShadowJar) {
	extension.relocate.each { it ->
		if (it.isEmpty()) {
			return
		}
		def relocateFrom = ""
		def relocateTo = ""
		if (it.contains(":")) {
			relocateFrom = it.split(":")[0]
			relocateTo = it.split(":")[1]
		} else {
			relocateFrom = it
			relocateTo = (project.group + '.' + project.name + '.' + relocateFrom)
					.replaceAll('[^a-zA-Z\\.]','')
		}
		logger.lifecycle("Relocating ${relocateFrom} to ${relocateTo}")
		shadowJar {
			relocate relocateFrom, relocateTo
		}
	}
	shadowJar {
		archiveBaseName.set(project.name)
		archiveClassifier.set('')
		archiveVersion.set(project.version)
	}
	build.dependsOn shadowJar
} else {
	logger.lifecycle("Not including shadow jar.")
}

/**
 * GRADLE
 */
if (extension.repoType == "GRADLE"
		&& extension.publishGradlePluginToGradlePortal) {
	def pluginId = (project.group + '.' + project.name)
			.replaceAll("[\"']","")
	if (extension.stripGradlePluginSuffix) {
		pluginId = pluginId.replaceAll(/-gradle-plugin$/,"")
	}
	def displayNameValue = (name.substring(0, 1).toUpperCase() + name.substring(1))
			.replaceAll('-',' ')
			.replaceAll("[\"']","")
	logger.lifecycle("pluginId ${pluginId} displayName ${displayNameValue}")
	gradlePlugin {
		website = extension.website
		vcsUrl = extension.vcsUrl
		description = project.description.replaceAll("[\"']","")

		plugins {
			if (extension.addGradlePluginPlugins) {
				thePlugin {
					tags.set(extension.tags)
					description = project.description.replaceAll("[\"']","")
					id = pluginId
					displayName = displayNameValue
					implementationClass = extension.implementationClass
				}
			}
			if (extension.adjustExistingGradlePluginPlugins) {
				matching { it.name.startsWith(project.group) }.configureEach {
					tags.set(extension.tags)
					description = project.description.replaceAll("[\"']","")
					id = pluginId
					displayName = displayNameValue
					implementationClass = extension.implementationClass
				}
			}
		}
	}
}

/**
 * Maven publishing
 */
if (extension.repoType != "GRADLE") {
	java {
		withSourcesJar()
		withJavadocJar()
	}

	publishing {
		publications {
			mavenJava(MavenPublication) { publication ->
				if (extension.useShadowJar) {
					logger.lifecycle("shadow jar in maven publication")
					project.shadow.component(publication)
					artifact javadocJar
					artifact sourcesJar
				} else {
					logger.lifecycle("Regular jar in maven publication")
					from project.components.java
				}

				logger.lifecycle("group: ${project.group} name: ${project.name}")
				groupId project.group.replaceAll("[\"']","")
				artifactId project.name.replaceAll("[\"']","")
				version version

				versionMapping {
					allVariants {
						fromResolutionResult()
					}
				}
			}
		}
	}
}

afterEvaluate {
	tasks.withType(GenerateMavenPom) { task ->
		doFirst {
			task.pom.description = project.description.replaceAll("[\"']","")
			task.pom.name = project.name
			task.pom.withXml {
				def root = asNode()
				root.appendNode('url', extension.website)
				root.appendNode('inceptionYear', new Date().getYear() + 1900)
				root.children().last() + {
					scm {
						url extension.website
						connection extension.vcsUrl
						developerConnection extension.vcsUrl
					}

					licenses {
						license {
							name extension.licenseName
							url extension.licenseUrl
							distribution 'repo'
						}
					}

					developers {
						developer {
							id extension.developerId
							name extension.developerName
							email extension.developerEmail
						}
					}
				}
			}
		}
	}
}

java {
	withSourcesJar()
	withJavadocJar()
}

nexusPublishing {
	repositories {
		sonatype {
			nexusUrl = uri(extension.mavenRepositoryUrl)
			username = findEnvOrPropValue(extension.nexusUsernameEnvOrProp)
			password = findEnvOrPropValue(extension.nexusPasswordEnvOrProp)
		}
	}
}

signing {
	def signingKey = findEnvOrPropValue(extension.signingKeyEnvOrProp)
	def signingPassword = findEnvOrPropValue(extension.signingPasswordEnvOrProp)
	def hasSigningCredentials = signingKey != null && signingPassword != null
	// I use "signing.keyId" prop when building locally, remote probably different and it probably has in memory
	def assumeThereIsAnInMemoryPgpKeys = extension.signingKeyEnvOrProp != "signing.keyId"


	required {
		hasSigningCredentials && gradle.taskGraph.hasTask("closeAndReleaseStagingRepositories")
	}

	if (assumeThereIsAnInMemoryPgpKeys && hasSigningCredentials) {
		logger.lifecycle("Configuring signing key and password")
		useInMemoryPgpKeys(signingKey, signingPassword)
	} else {
		logger.lifecycle("Not configuring signing key and password")
	}
	sign(publishing.publications)
}

tasks.withType(AbstractPublishToMaven) { publishTask ->
	tasks.withType(Sign) { signTask ->
		logger.info("${publishTask} must run after ${signTask}")
		publishTask.mustRunAfter(signTask)
		tasks.withType(Jar) { jarTask ->
			logger.info("${signTask} must run after ${jarTask}")
			signTask.mustRunAfter(jarTask)
		}
	}
}

/**
 * Release process
 */
task release(type: GradleBuild) {
	tasks = ['clean']
	if (extension.setVersionConventional) {
		tasks += [
			'gitChangelogSemanticVersion',
			'commitNewVersionTask',
		]
	}

	tasks += ['publishToMavenLocal',]

	if (extension.repoType == "GRADLE"
			&& extension.publishGradlePluginToGradlePortal) {
		tasks += ["publishPlugins"]
	} else {
		tasks += [
			"publish",
			"closeAndReleaseStagingRepositories",
		]
	}
	if (extension.updateChangelog) {
		tasks += [
			'gitChangelog',
			'commitChangelogTask'
		]
	}

	if (extension.repoType == 'COMMAND') {
		tasks += [
			"setupNpmJavaRunnerFiles",
			"publishNpm"
		]
	}
}

/**
 * Supporting methods
 */
def findResource(String name, classLoader = project.buildscript.classLoader) {
	URL resource = classLoader.getResource(name)
	if (resource == null) {
		logger.lifecycle("Cannot find resource \"${name}\"")
		return null;
	}
	return resource
}

def copyResourceToFile(URL resource, String copyTo, classLoader = project.buildscript.classLoader) {
	logger.lifecycle("Copying ${resource} to ${copyTo}")
	def content = resource.text
	def parentFile = new File(copyTo).getParentFile()
	if (parentFile != null) {
		parentFile.mkdirs()
	}
	FileWriter fw = new FileWriter(copyTo)
	BufferedWriter bw = new BufferedWriter(fw)
	bw.write(content)
	bw.close()
}

def copyIfFound(String name, String target=null, classLoader = project.buildscript.classLoader) {
	URL resource = findResource(name, classLoader)
	if (resource != null) {
		logger.lifecycle("Found resource ${name} as ${resource}")
		def newFilename = target == null ? "$buildDir/$name" : target
		copyResourceToFile(resource, newFilename)
		return new File(newFilename)
	}
}

def shouldGitIgnore(filename) {
	if (!file('.gitignore').text.contains(filename)) {
		throw new RuntimeException("The .gitignore should include '${filename}'")
	}
	logger.lifecycle("${filename} is ignored")
}

def findEnvOrPropValue(variable) {
	def envValue = providers.environmentVariable(variable).orElse("").get()
	def propValue = project.findProperty(variable)
	if (!envValue.isEmpty()) {
		return envValue
	}
	return propValue;
}

def runCommand(args, int attempts = 5) {
	logger.lifecycle("Executing ${args.join(' ')}")
	def stdout = new ByteArrayOutputStream()
	try {
		exec {
			commandLine args
			standardOutput = stdout
		}
		return stdout.toString().trim()
	} catch (e) {
		def err = stdout.toString().trim() + "\n" + "Command: ${args.join(' ')}" + "\n" + "Trying ${attempts} more times"
		logger.lifecycle(err)
		if (attempts == 0) {
			throw new RuntimeException(err, e)
		}
		sleep(5 * 1000)
		return runCommand(args, attempts - 1)
	}
}

task commitNewVersionTask() {
	doLast {
		try {
			runCommand([
				'git',
				'commit',
				'-a',
				'-m',
				"chore(release): ${version} [GRADLE SCRIPT]"
			])
			runCommand(['git', 'push'])
		} catch (e) {
			logger.error("Unable commit/push new version, skipping that.",e.getMessage())
		}

		try {
			runCommand(['git', 'tag', "${version}"])
			runCommand([
				'git',
				'push',
				'origin',
				"${version}"
			])
			runCommand(['git', 'push', '--tags'])
		} catch (e) {
			logger.error("Unable tag new version, skipping that.",e.getMessage())
		}
	}
}

task commitChangelogTask() {
	doLast {
		try {
			runCommand([
				'git',
				'commit',
				'-a',
				'-m',
				"chore(release): Updating changelog with ${version} [GRADLE SCRIPT]"
			])
			runCommand(['git', 'push'])
		} catch (e) {
			logger.error("Unable commit/push changelog, skipping that.",e.getMessage())
		}
	}
}